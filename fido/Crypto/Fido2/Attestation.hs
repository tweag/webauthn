{-# LANGUAGE NamedFieldPuns #-}

-- | Implements steps 1 to 16 of <https://www.w3.org/TR/webauthn/#registering-a-new-credential "7.1.  Registering a New Credential">
module Crypto.Fido2.Attestation
  ( verifyAttestationResponse,
    Error (..),
  )
where

import Codec.CBOR.Term (Term)
import Control.Monad (when)
import Crypto.Fido2.Protocol
  ( AttestationObject (AttestationObject, attStmt, authData, fmt),
    AttestedCredentialData,
    AuthenticatorAttestationResponse (AuthenticatorAttestationResponse, attestationObject, clientData),
    AuthenticatorData (AuthenticatorData, attestedCredentialData, rpIdHash, userPresent, userVerified),
    Challenge,
    ClientData (ClientData, challenge, clientDataHash, origin, typ),
    Origin,
    RpId (unRpId),
    URLEncodedBase64 (),
    UserVerificationRequirement (UserVerificationRequired),
    WebauthnType (Create),
  )
import qualified Crypto.Hash as Hash
import Crypto.Hash (Digest, SHA256)
import Data.Text (Text)
import qualified Data.Text.Encoding as Text

data Error
  = InvalidWebauthnType
  | ChallengeDidNotMatch
  | OriginDidNotMatch
  | RpIdMismatch
  | UserNotPresent
  | UserNotVerified
  | UnsupportedAttestationFormat
  | InvalidAttestationStatement
  | NoAttestedCredentialDataFound
  | NotTrustworthy
  deriving (Show, Eq)

-- | Use this result to implement step 17, 18 and 19 of
-- <https://www.w3.org/TR/webauthn/#registering-a-new-credential "7.1.
-- Registering a New Credential">
--
-- 17 Check that the 'credentialId' is not yet registered to any other user.
-- If registration is requested for a credential that is already registered to
-- a different user, the Relying Party SHOULD fail this registration ceremony,
-- or it MAY decide to accept the registration, e.g. while deleting the older
-- registration.
--
-- 18 If the attestation statement 'attStmt' verified successfully and is
-- found to be trustworthy, then register the new credential with the account
-- that was denoted in the options.user passed to create(), by associating it
-- with the 'credentialId' and 'credentialPublicKey' in the
-- 'attestedCredentialData' in 'authData', as appropriate for the Relying
-- Party's system.
--
--
-- 19 If the attestation statement attStmt successfully verified but is not
-- trustworthy per step 16 above, the Relying Party SHOULD fail the
-- registration ceremony.
--
-- NOTE: However, if permitted by policy, the Relying Party MAY register the
-- credential ID and credential public key but treat the credential as one with
-- self attestation (see §6.4.3 Attestation Types). If doing so, the Relying
-- Party is asserting there is no cryptographic proof that the public key
-- credential has been generated by a particular authenticator model.
--
-- Verification of attestation objects requires that the Relying Party has a
-- trusted method of determining acceptable trust anchors in step 15 above.
-- Also, if certificates are being used, the Relying Party MUST have access to
-- certificate status information for the intermediate CA certificates. The
-- Relying Party MUST also be able to build the attestation certificate chain
-- if the client did not provide this chain in the attestation information.

-- | Runs step 1 to 16 of
-- <https://www.w3.org/TR/webauthn/#registering-a-new-credential "7.1.  Registering a New Credential">
--
-- Steps 17, 18 and 19 should be taken care of by the caller of the API. The
-- function returns all the information needed for these steps.
verifyAttestationResponse ::
  Origin ->
  RpId ->
  Challenge ->
  UserVerificationRequirement ->
  AuthenticatorAttestationResponse ->
  Either Error AttestedCredentialData
verifyAttestationResponse
  origin
  rpId
  challenge
  userVerificationRequirement
  AuthenticatorAttestationResponse {clientData, attestationObject} = do
    -- 1. Let JSONtext be the result of running UTF-8 decode on the value of
    -- response.clientDataJSON.
    --
    -- --> This is implied in the decoder of 'AuthenticatorAttestationResponse'
    --
    --
    -- 2. Let C, the client data claimed as collected during the credential
    -- creation, be the result of running an implementation-specific JSON parser on
    -- JSONtext.
    --
    -- --> This is implied in the decoder of 'AuthenticatorAttestationResponse'
    --
    -- 3. Verify that the value of C.type is webauthn.create.
    let ClientData {typ} = clientData
    when (typ /= Create) $ Left InvalidWebauthnType
    -- 4. Verify that the value of C.challenge matches the challenge that was
    -- sent to the authenticator in the create() call.
    let ClientData {challenge = challenge'} = clientData
    when (challenge /= challenge') $ Left ChallengeDidNotMatch
    -- 5. Verify that the value of C.origin matches the Relying Party's origin.
    let ClientData {origin = origin'} = clientData
    when (origin /= origin') $ Left OriginDidNotMatch
    -- 6. Verify that the value of C.tokenBinding.status matches the state of
    -- Token Binding for the TLS connection over which the assertion was
    -- obtained. If Token Binding was used on that TLS connection, also verify
    -- that C.tokenBinding.id matches the base64url encoding of the Token Binding
    -- ID for the connection.
    --
    -- --> TODO(arianvp): TokenBinding is not yet supported. Ignore

    -- 7. Compute the hash of response.clientDataJSON using SHA-256.
    -- --> Already available as 'clientDataHash'
    let ClientData {clientDataHash} = clientData
    -- 8. Perform CBOR decoding on the attestationObject field of the
    -- AuthenticatorAttestationResponse structure to obtain the attestation
    -- statement format fmt, the authenticator data authData, and the attestation
    -- statement attStmt.
    let AttestationObject {fmt, authData, attStmt} = attestationObject
    -- 9. Verify that the rpIdHash in authData is the SHA-256 hash of the RP ID
    -- expected by the Relying Party.
    let AuthenticatorData {rpIdHash} = authData
    when (Hash.hash (Text.encodeUtf8 . unRpId $ rpId) /= rpIdHash) $ Left RpIdMismatch
    -- 10. Verify that the User Present bit of the flags in authData is set.
    let AuthenticatorData {userPresent} = authData
    when (not userPresent) $ Left UserNotPresent
    -- 11. If user verification is required for this registration, verify that
    -- the User Verified bit of the flags in authData is set.
    let AuthenticatorData {userVerified} = authData
    when (userVerificationRequirement == UserVerificationRequired && (not userVerified)) $ Left UserNotVerified
    -- 12. Verify that the values of the client extension outputs in
    -- clientExtensionResults and the authenticator extension outputs in the
    -- extensions in authData are as expected, considering the client extension
    -- input values that were given as the extensions option in the create()
    -- call. In particular, any extension identifier values in the
    -- clientExtensionResults and the extensions in authData MUST be also be
    -- present as extension identifier values in the extensions member of
    -- options, i.e., no extensions are present that were not requested. In the
    -- general case, the meaning of "are as expected" is specific to the
    -- Relying Party and which extensions are in use.
    -- --> TODO: We do not implement any client extensions currently

    -- 13. Determine the attestation statement format by performing a USASCII
    -- case-sensitive match on fmt against the set of supported WebAuthn
    -- Attestation Statement Format Identifier values. An up-to-date list of
    -- registered WebAuthn Attestation Statement Format Identifier values is
    -- maintained in the IANA registry of the same name [WebAuthn-Registries].
    -- NOTE: We currently only support the '"none"' attestation format
    -- 14. Verify that attStmt is a correct attestation statement, conveying a valid
    -- attestation signature, by using the attestation statement format fmt’s
    -- verification procedure given attStmt, authData and the hash of the
    -- serialized client data computed in step 7.

    -- 15. If validation is successful, obtain a list of acceptable trust
    -- anchors (attestation root certificates or ECDAA-Issuer public keys) for
    -- that attestation type and attestation statement format fmt, from a
    -- trusted source or from policy. For example, the FIDO Metadata Service
    -- [FIDOMetadataService] provides one way to obtain such information, using
    -- the aaguid in the attestedCredentialData in authData.

    -- 16. Assess the attestation trustworthiness using the outputs of the
    -- verification procedure in step 14, as follows:
    -- If self attestation was used, check if self attestation is acceptable
    -- under Relying Party policy.
    -- If ECDAA was used, verify that the identifier of the ECDAA-Issuer
    -- public key used is included in the set of acceptable trust anchors
    -- obtained in step 15.
    -- Otherwise, use the X.509 certificates returned by the verification
    -- procedure to verify that the attestation public key correctly chains up
    -- to an acceptable root certificate.
    -- --> TODO: This is a no-op as we only support "none"
    validateAttStmt fmt attStmt authData clientDataHash

validateAttStmt :: Text -> [(Term, Term)] -> AuthenticatorData -> Digest SHA256 -> Either Error AttestedCredentialData
validateAttStmt "none" [] AuthenticatorData {attestedCredentialData} _ =
  case attestedCredentialData of
    Just attestedCredentialData -> pure $ attestedCredentialData
    Nothing -> Left NoAttestedCredentialDataFound
validateAttStmt "none" _ _ _ = Left InvalidAttestationStatement
validateAttStmt _ _ _ _ = Left UnsupportedAttestationFormat
