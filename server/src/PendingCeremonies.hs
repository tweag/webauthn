{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- | This module implements a secure and efficient way to temporarily store
-- webauthn options for the create/register and get/login webauthn operations
-- along with generating the challenge needed for them.
module PendingCeremonies
  ( PendingCeremoniesConfig (..),
    defaultPendingCeremoniesConfig,
    newPendingCeremonies,
    PendingCeremonies,
    insertPendingRegistration,
    insertPendingAuthentication,
    getPendingRegistration,
    getPendingAuthentication,
  )
where

import Control.Concurrent (forkIO, threadDelay)
import qualified Control.Concurrent.STM as STM
import Control.Monad (forever, unless, when)
import qualified Crypto.WebAuthn as WA
import Data.Binary (Binary)
import qualified Data.Binary as Binary
import qualified Data.Binary.Get as Binary
import qualified Data.Binary.Put as Binary
import qualified Data.ByteString.Lazy as LBS
import Data.Int (Int64)
import Data.Map (Map)
import qualified Data.Map as Map
import System.Clock (Clock (Realtime), TimeSpec (sec), getTime)

-- | Configuration for the pending ceremony management
data PendingCeremoniesConfig = PendingCeremoniesConfig
  { -- | The minimum time in seconds that a pending operation should be waited for to complete
    validTime :: Int64,
    -- | The interval in seconds at which pending operations should be checked for expiration
    expireInterval :: Int,
    -- | The number of random bytes the challenge should contain. Should be at least 16
    challengeBytes :: Int
  }

-- | The default config: Ceremonies are expired after 5 minutes, they get
-- cleaned up every 10 seconds, and challenges are 16 bytes long
defaultPendingCeremoniesConfig :: PendingCeremoniesConfig
defaultPendingCeremoniesConfig =
  PendingCeremoniesConfig
    { validTime = 5 * 60,
      expireInterval = 10,
      challengeBytes = 16
    }

-- | An 'M.Challenge' that expires after a certain time.
data ExpiringChallenge = ExpiringChallenge
  { -- | The unix epoch seconds after which this challenge is expired
    -- This is exposed to the clients, but this is not a vulnerability, see
    -- <https://security.stackexchange.com/questions/187316/is-exposing-the-server-time-a-security-risk>.
    -- This field intentionally comes _before_ the 'randomness' field, such that
    -- the derived 'Ord' instance orders challenges according to their expiration
    -- time, which allows much faster periodic expiration
    expiredAfter :: Int64,
    -- | The random part of the challenge
    randomness :: WA.Challenge
  }
  deriving (Show, Eq, Ord)

-- | The current time in seconds for challenge expiration
getNow :: IO Int64
getNow =
  -- We're only interested in second-resolution
  sec
    -- While realtime can have backwards jumps with leap seconds, that's not a
    -- problem since our expiration times are on the order of minutes, and it's
    -- pretty clear that realtime isn't a security problem, see
    -- <https://security.stackexchange.com/questions/187316/is-exposing-the-server-time-a-security-risk>
    <$> getTime Realtime

isExpired :: Int64 -> ExpiringChallenge -> Bool
isExpired now challenge = expiredAfter challenge < now

-- | This instance is used to turn an 'ExpiringChallenge' into an 'M.Challenge' and back
instance Binary ExpiringChallenge where
  put ExpiringChallenge {expiredAfter, randomness} = do
    Binary.putInt64le expiredAfter
    Binary.putByteString (WA.unChallenge randomness)
  get =
    ExpiringChallenge
      <$> Binary.getInt64le
      <*> (WA.Challenge . LBS.toStrict <$> Binary.getRemainingLazyByteString)

type Pendings c = STM.TVar (Map ExpiringChallenge (WA.CredentialOptions c))

-- | The data structure that stores pending ceremonies in memory
data PendingCeremonies = PendingCeremonies
  { pendingRegisters :: Pendings 'WA.Registration,
    pendingLogins :: Pendings 'WA.Authentication,
    pendingConfig :: PendingCeremoniesConfig
  }

-- | Stores a new pending registration ceremony in memory along with its
-- 'M.CredentialOptions' options. The challenge to be used for the options is
-- generated by this function.
insertPendingRegistration ::
  PendingCeremonies ->
  -- | Given a generated challenge, what are the complete options. The challenge
  -- needs to be used for the options 'M.corChallenge' field
  (WA.Challenge -> WA.CredentialOptions 'WA.Registration) ->
  IO (WA.CredentialOptions 'WA.Registration)
insertPendingRegistration PendingCeremonies {..} = insert pendingConfig pendingRegisters

-- | Stores a new pending authentication ceremony in memory along with its
-- 'M.CredentialOptions' options. The challenge to be used for the options is
-- generated by this function.
insertPendingAuthentication ::
  PendingCeremonies ->
  -- | Given a generated challenge, what are the complete options. The challenge
  -- needs to be used for the options 'M.coaChallenge' field
  (WA.Challenge -> WA.CredentialOptions 'WA.Authentication) ->
  IO (WA.CredentialOptions 'WA.Authentication)
insertPendingAuthentication PendingCeremonies {..} = insert pendingConfig pendingLogins

-- | Generic shared implementation of the 'insertPendingRegistration' and
-- 'insertPendingAuthentication' functions
insert ::
  PendingCeremoniesConfig ->
  Pendings c ->
  (WA.Challenge -> WA.CredentialOptions c) ->
  IO (WA.CredentialOptions c)
insert cfg pending create = do
  expiringChallenge <- generateExpiringChallenge
  let challenge = WA.Challenge $ LBS.toStrict $ Binary.encode expiringChallenge
      value = create challenge
  STM.atomically $ STM.modifyTVar pending $ Map.insert expiringChallenge value
  pure value
  where
    generateExpiringChallenge :: IO ExpiringChallenge
    generateExpiringChallenge = do
      now <- getNow
      -- We only look at seconds, not nanoseconds
      -- 1 hour expiration time, no real reason
      let expiredAfter = now + validTime cfg

      randomness <- WA.generateChallenge

      pure $ ExpiringChallenge {..}

-- | Gets a pending registration ceremony in memory along with its 'M.CredentialOptions',
-- given a 'M.Credential' which contains the challenge previously generated by 'insertPendingRegistration'.
-- This deletes the options from memory again. If the challenge is expired an error is returned
getPendingRegistration ::
  PendingCeremonies ->
  -- The credential that was received as a reply
  WA.Credential 'WA.Registration raw ->
  IO (Either String (WA.CredentialOptions 'WA.Registration))
getPendingRegistration pending cred = get (pendingRegisters pending) (WA.ccdChallenge $ WA.arrClientData $ WA.cResponse cred)

-- | Gets a pending registration ceremony in memory along with its 'M.CredentialOptions',
-- given a 'M.Credential' which contains the challenge previously generated by 'insertPendingRegistration'.
-- This deletes the options from memory again. If the challenge is expired an error is returned
getPendingAuthentication ::
  PendingCeremonies ->
  -- The credential that was received as a reply
  WA.Credential 'WA.Authentication raw ->
  IO (Either String (WA.CredentialOptions 'WA.Authentication))
getPendingAuthentication pending cred = get (pendingLogins pending) (WA.ccdChallenge $ WA.araClientData $ WA.cResponse cred)

-- | Generic shared implementation of the 'getPendingRegistration' and
-- 'getPendingAuthentication' functions
get ::
  Pendings c ->
  WA.Challenge ->
  IO (Either String (WA.CredentialOptions c))
get pending (WA.Challenge challenge) = case Binary.decodeOrFail (LBS.fromStrict challenge) of
  Left (_, _, err) -> pure $ Left $ "Decoding challenge failed: " <> err
  Right (_, _, expiringChallenge) -> do
    now <- getNow
    -- The client has to send back the correct expired time, so we don't
    -- even need to do an STM action if it's expired already
    -- This is safe because if the expired time is wrong for a specific
    -- challenge, it would just not be found in the map in the following step
    if isExpired now expiringChallenge
      then pure $ Left "Challenge expired"
      else STM.atomically $ do
        contents <- STM.readTVar pending
        let result = Map.lookup expiringChallenge contents
        -- Delete the challenge, it should only be usable a single time
        STM.writeTVar pending $ Map.delete expiringChallenge contents
        pure $ case result of
          Just options -> Right options
          Nothing -> Left "Challenge not known or expired"

-- | Creates a new managed 'PendingCeremonies' value that tracks pending webauthn
-- ceremonies according to the given 'PendingCeremoniesConfig'.
-- The result can be used with functions 'insertPendingRegistration',
-- 'insertPendingAuthentication', 'getPendingRegistration' and
-- 'getPendingAuthentication'
newPendingCeremonies ::
  PendingCeremoniesConfig ->
  IO PendingCeremonies
newPendingCeremonies pendingConfig = do
  -- [(spec)](https://www.w3.org/TR/webauthn-2/#sctn-cryptographic-challenges)
  -- In order to prevent replay attacks, the challenges MUST contain enough entropy
  -- to make guessing them infeasible. Challenges SHOULD therefore be at least 16 bytes long.
  when (challengeBytes pendingConfig < 16) $ fail "newPendingCeremonies: challengeBytes needs to be at least 16 [bytes]"
  pendingRegisters <- STM.newTVarIO Map.empty
  pendingLogins <- STM.newTVarIO Map.empty
  let pendings = PendingCeremonies {..}
  -- Clean up pending ceremonies over time to prevent leaking memory for
  -- ceremonies that are only started but never finished
  _ <- forkIO $ expireLoop pendings
  pure pendings
  where
    expireLoop :: PendingCeremonies -> IO ()
    expireLoop pending = forever $ do
      now <- getNow
      expireChallenges now (pendingRegisters pending)
      expireChallenges now (pendingLogins pending)
      threadDelay (1000 * 1000 * expireInterval pendingConfig)

    expireChallenges ::
      Int64 ->
      Pendings c ->
      IO ()
    expireChallenges now pendings = do
      expired <- STM.atomically $ do
        ops <- STM.readTVar pendings
        -- 'Map.spanAntitone' is an efficient (O(log n)) way to split the map into a
        -- set of expired and a set of still valid ceremonies, this is only
        -- possible because 'ExpiringChallenge's 'Ord' instance orders according
        -- to 'expiredAfter' time first
        let (expired, valid) = Map.spanAntitone (isExpired now) ops
        STM.writeTVar pendings valid
        pure expired
      -- TODO: Do something less invasive than printing the removed options,
      -- this is desirable when this module is included as part of the library,
      -- and we no longer want to write to stdout.
      unless (Map.null expired) $ putStrLn $ "Removed these expired pending ceremonies: " <> show expired
